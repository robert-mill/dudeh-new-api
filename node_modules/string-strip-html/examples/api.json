{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nassert.equal(\n  stripHtml(`Some text <b>and</b> text.`).result,\n  `Some text and text.`\n);\n\n// prevents accidental string concatenation\nassert.equal(stripHtml(`aaa<div>bbb</div>ccc`).result, `aaa bbb ccc`);\n\n// tag pairs with content, upon request\nassert.equal(\n  stripHtml(`a <pre><code>void a;</code></pre> b`, &#x7B;\n    stripTogetherWithTheirContents: [\n      \"script\", // default\n      \"style\", // default\n      \"xml\", // default\n      \"pre\", // <-- custom-added\n    ],\n  &#x7D;).result,\n  `a b`\n);\n\n// detects raw, legit brackets:\nassert.equal(stripHtml(`a < b and c > d`).result, `a < b and c > d`);"},"extract-html-head-contents.js":{"title":"Extract HTML head contents","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>\n  <body>\n    the content\n  </body>\n</html>`;\n\n// The task asks not to include <head...> and </head>.\n// First, extract head tag-to-head tag, including contents\nconst headWithHeadTags = stripHtml(someHtml, &#x7B;\n  onlyStripTags: [\"head\"],\n  stripTogetherWithTheirContents: [\"head\"],\n&#x7D;)\n  .filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  )\n  .trim();\n\nassert.equal(\n  headWithHeadTags,\n  `<head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>`\n);\n\nconst headContents = headWithHeadTags.replace(/<\\/?head>/g, \"\").trim();\nassert.equal(\n  headContents,\n  `<meta charset=\"utf-8\">\n    <title>the title</title>`\n);"},"leave-only-html.js":{"title":"Leave only HTML","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(\n  stripHtml(someHtml).allTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<!DOCTYPE html><html lang=\"en\" dir=\"ltr\"><head><meta charset=\"utf-8\"><title></title></head><body><h1></h1></body></html>`\n);"},"leave-only-opening-td.js":{"title":"Leave only opening td tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\n// the first way\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    // notice there's no: onlyStripTags: [\"td\"]\n    // we operate purely via callback\n    cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n      if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n        rangesArr.push(proposedReturn);\n      &#x7D;\n    &#x7D;,\n  &#x7D;).ranges.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to).trim()&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);\n\n// the second way:\n// -----------------------------------------------------------------------------\n\nlet resultStr = \"\";\n// notice we don't even assign stripHtml() output to anything - we rely only\n// on the callback, it mutates the \"resultStr\" in the upper scope\nstripHtml(someHtml, &#x7B;\n  // notice there's no: onlyStripTags: [\"td\"]\n  // we operate purely via callback\n  cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n    if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n      resultStr += someHtml.slice(deleteFrom, deleteTo).trim();\n    &#x7D;\n  &#x7D;,\n&#x7D;);\nassert.equal(\n  resultStr,\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);"},"leave-only-td.js":{"title":"Leave only td tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    onlyStripTags: [\"td\"],\n  &#x7D;).filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"></td><td class=\"col2\"></td><td class=\"col3\"></td><td class=\"col4\"></td>`\n);"},"remove-html.js":{"title":"Remove all HTML from a string","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(stripHtml(someHtml).result, `Title\\nSome text.`);"}}